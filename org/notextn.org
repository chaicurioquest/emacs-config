#+TITLE: Bibliography and Org-Noter Integration
#+TODO: ACTIVE | CANCELLED
#+STARTUP: indent
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+DATE: 2025-10-20
#+CREATED: %U
#+LAST_MODIFIED: [%<%Y-%m-%d %a %H:%M>]

This file provides a clean, minimal, and robust integration between:
- Citar
- Org-roam
- PDF Tools
- Org-Noter

It handles both bibliography notes and generic PDFs (books, whitepapers, etc.)
with a unified command set under =C-c i=.

* Core Functions

#+BEGIN_SRC emacs-lisp
;;; notextn.el --- Org-noter + Citar + PDF Tools integration -*- lexical-binding: t; -*-
;; Required packages
(require 'org)
(require 'org-id)
(require 'org-noter)
#+END_SRC

** Winprops + Org-noter Settings

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Fix "wrong-type-argument listp t" from image-mode-winprops
;; ──────────────────────────────────────────────────────────────
(defun my/sanitize-image-winprops-in-doc-window (orig &rest args)
  "Initialize image-mode-winprops-alist in the Org-noter document window before calling ORIG."
  (let ((doc-win (org-noter--get-doc-window)))
    (when (and doc-win (window-live-p doc-win))
      (with-selected-window doc-win
        (image-mode-setup-winprops))))
  (apply orig args))

(with-eval-after-load 'org-noter
  ;; ── Settings (here to guarantee application after org-noter loads) ──
  (setq org-noter-notes-search-path
        (list (expand-file-name "literature" org-roam-directory))
        org-noter-auto-save-last-location nil
        org-noter-highlight-selected-text nil
        org-noter-insert-note-no-questions t   ;; ← fixes "No match" prompt
        org-noter-hide-other nil
        org-noter-always-create-frame nil)
  ;; ── winprops fix ──
  (advice-add 'org-noter--doc-approx-location :around
              #'my/sanitize-image-winprops-in-doc-window))

(add-hook 'pdf-view-mode-hook #'image-mode-setup-winprops)
(add-hook 'image-mode-hook #'image-mode-setup-winprops)
#+END_SRC

** Org-noter-pdftools Fixes

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Fix "wrong-type-argument listp #s(org-noter-pdftools--location ...)"
;; ──────────────────────────────────────────────────────────────
(with-eval-after-load 'org-noter-pdftools
  (defun my/org-noter-convert-location-to-cons (loc)
    "Convert org-noter-pdftools location struct to (page . top) cons."
    (cond
     ((consp loc) loc)
     ((org-noter-pdftools--location-p loc)
      (cons (org-noter-pdftools--location-page loc)
            (org-noter-pdftools--location-height loc)))
     (t (error "Invalid location: %S" (type-of loc)))))

  (advice-add 'org-noter--pretty-print-location-for-title :around
              (lambda (orig loc &rest args)
                (let ((converted-loc (my/org-noter-convert-location-to-cons loc)))
                  (apply orig converted-loc args))))

  ;; FIX: Enhanced jump handler to bridge PDF and Org windows
  (advice-add 'org-noter-pdftools-jump-to-note :around
              (lambda (orig &rest args)
                (condition-case nil
                    (let ((session (or (and (boundp 'org-noter--session) org-noter--session)
                                       (with-selected-window (next-window)
                                         (and (boundp 'org-noter--session) org-noter--session)))))
                      (if session
                          (apply orig args)
                        (message "Org-noter jump: No session found. Try M-x org-noter first.")))
                  (error (message "Org-noter jump failed: Window configuration error."))))))
#+END_SRC

** Relative Path Portability

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Use relative paths whenever possible (portability++)
;; ──────────────────────────────────────────────────────────────
(advice-add 'org-noter--add-doc :around
            (lambda (orig doc-file &rest args)
              (let ((rel (and (buffer-file-name)
                              (file-relative-name doc-file
                                                  (file-name-directory (buffer-file-name))))))
                (apply orig (if (and rel (not (string-prefix-p "../" rel))) rel doc-file)
                       args))))
#+END_SRC

** Citar Path Helper

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Helper: first PDF path from Citar
;; ──────────────────────────────────────────────────────────────
(defun my/citar-extract-first-path (x)
  "Return first string path in X or nil."
  (cond ((null x) nil)
        ((stringp x) x)
        ((vectorp x) (when (> (length x) 0) (my/citar-extract-first-path (aref x 0))))
        ((listp x) (my/citar-extract-first-path (car x)))
        ((hash-table-p x) (let (found)
                            (maphash (lambda (_ v)
                                       (unless found
                                         (setq found (my/citar-extract-first-path v))))
                                     x)
                            found))
        (t nil)))
#+END_SRC

** Normalize Note File

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Normalize note file
;; ──────────────────────────────────────────────────────────────
(defun my/bibnote-normalize-file (note-file &optional pdf title)
  "Ensure NOTE-FILE has proper structure and properties.
Kills buffer after saving only if this function opened it."
  (let* ((existing-buf (get-file-buffer note-file))
         (buf (or existing-buf (find-file-noselect note-file))))
    (with-current-buffer buf
      (save-excursion
        (goto-char (point-min))
        (unless (re-search-forward "^\\*\\s-+\\S-" nil t)
          (goto-char (point-max))
          (insert (format "* %s\n\n" (or title "Overview"))))
        (goto-char (point-min))
        (re-search-forward "^\\*\\s-+\\S-")
        (unless (org-entry-get (point) "ID") (org-id-get-create))
        (when pdf
          (org-entry-put (point) "NOTER_DOCUMENT" (expand-file-name pdf)))
        (goto-char (point-min))
        (unless (re-search-forward "^\\*+\\s-+Analysis and Inference\\b" nil t)
          (goto-char (point-max))
          (unless (bolp) (insert "\n"))
          (insert "* Analysis and Inference\n\n")))
      (when (buffer-modified-p) (save-buffer)))
    (unless existing-buf (kill-buffer buf)))
  note-file)
#+END_SRC

** Templates

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Templates & helpers (no dead Bib Entry)
;; ──────────────────────────────────────────────────────────────
(defun my/load-template (filename)
  "Load template or return clean fallback."
  (let ((path (expand-file-name filename (expand-file-name "template" user-emacs-directory))))
    (if (file-exists-p path)
        (with-temp-buffer (insert-file-contents path) (buffer-string))
      (message "Template %s not found; using fallback." path)
      "#+TITLE: %s\n#+ROAM_ALIASES: %s\n#+ROAM_REFS: cite:%s\n* Overview\n:PROPERTIES:\n:AUTHOR: %s\n:DOI: %s\n:YEAR: %s\n:NOTER_DOCUMENT: %s\n:ID: %s\n:END:\n* Analysis and Inference\n")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Bibliography note template
;; ──────────────────────────────────────────────────────────────
(defun my/load-roam-bib-template (&optional citekey title)
  "Generate bibliography note from Citar entry."
  (let* ((template (my/load-template "roam-bib.org"))
         (citekey (or citekey (plist-get org-roam-capture--info 'citar-citekey) ""))
         (entry (ignore-errors (when citekey (citar-get-entry citekey))))
         (title (or title (plist-get org-roam-capture--info 'title)
                    (and entry (cdr (assoc "title" entry))) "Untitled"))
         (author (or (and entry (cdr (assoc "author" entry))) ""))
         (doi (or (and entry (cdr (assoc "doi" entry))) ""))
         (date (or (and entry (cdr (assoc "date" entry))) ""))
         (year (or (and entry (cdr (assoc "year" entry)))
                   (and (> (length date) 3) (substring date 0 4)) ""))
         (file (or (ignore-errors (my/citar-extract-first-path (citar-get-files citekey))) ""))
         (noter-document (if (string-empty-p file) "" file))
         (id (org-id-new)))
    (format template title citekey citekey author doi year noter-document id)))
#+END_SRC

* PDF Selection and Openers

** Project PDF Selector

#+BEGIN_SRC emacs-lisp
;; Select PDF from project or browse
(defun my/select-pdf-project-or-browse ()
  "Select PDF project-wide (recursive, includes .attach) or browse manually."
  (interactive)
  (let* ((root (read-directory-name "Project root directory: " default-directory))
         (find-cmd (format "find %s \\( -type f -o -type l \\) -name '*.pdf'" root))
         (pdf-list (split-string (shell-command-to-string find-cmd) "\n" t))
         (choice (completing-read "Select project PDF (or type * for browser): "
                                  (append pdf-list '("* Browse anywhere...")) nil t)))
    (if (string= choice "* Browse anywhere...")
        (read-file-name "Select any file: " nil nil t)
      choice)))
#+END_SRC

** Unified Opener

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Unified opener
;; ──────────────────────────────────────────────────────────────
(defun my/open-pdf-and-note (&optional key-or-pdf)
  "Open PDF and note. Use 'generic for non-bib files."
  (interactive)
  (require 'citar nil t)
  (let* ((is-bib (not (eq key-or-pdf 'generic)))
         (key (if is-bib
                  (substring (or key-or-pdf (concat "@" (citar-select-ref))) 1)
                nil))
         (pdf-raw (if is-bib
                      (my/citar-extract-first-path (citar-get-files key))
                    (my/select-pdf-project-or-browse)))
         (pdf (cond
               ((bufferp pdf-raw) (buffer-file-name pdf-raw))
               ((stringp pdf-raw) pdf-raw)
               (t (user-error "PDF selection did not yield a valid path or buffer."))))
         (entry (when is-bib (ignore-errors (citar-get-entry key))))
         (title (or (when entry (cdr (assoc "title" entry)))
                    (and (stringp pdf) (file-name-base pdf))
                    "Overview"))
         (suggested-name (downcase (replace-regexp-in-string "[^a-z0-9-]" "-" title)))
         (note-file (if is-bib
                        (expand-file-name (concat key ".org")
                                          (expand-file-name "literature" org-roam-directory))
                      (let ((default-dir default-directory))
                        (make-directory default-dir t)
                        (read-file-name "Save note as: " default-dir nil nil
                                        (concat suggested-name ".org"))))))
    (unless (file-directory-p (file-name-directory note-file))
      (make-directory (file-name-directory note-file) t))
    (unless (file-exists-p note-file)
      (with-temp-file note-file
        (if is-bib
            (insert (my/load-roam-bib-template key title))
          (insert (format "#+TITLE: %s\n* Overview\n:PROPERTIES:\n:ID: %s\n:NOTER_DOCUMENT: %s\n:END:\n* Analysis and Inference\n"
                          title (org-id-new) (or pdf "")))))
      (my/bibnote-normalize-file note-file pdf title))
    (find-file pdf)
    (split-window-right)
    (find-file note-file)
    (goto-char (point-min))
    (re-search-forward "^\\* ")
    (when (bound-and-true-p org-noter--session)
      (org-noter-kill-session))
    (org-noter)
    (message "Opened %s note → %s"
             (if is-bib "bibliography" "generic")
             (file-name-nondirectory note-file))))
#+END_SRC

** Calibre Book Opener

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Calibre books – C-c i b (laptop only)
;; Workflow:
;; 1. M-x calibredb → opens Calibre library buffer.
;; 2. / term RET → optional: live-filter by text (title/author/tags).
;; 3. Move point to book → use n/p or arrow keys.
;; 4. C-c i b → opens book file left + Org note right in ~/org/books/.
;; ──────────────────────────────────────────────────────────────
(when (eq my-device 'laptop)
  (defun my/open-calibre-book-and-note ()
    "Open Calibre book (PDF/EPUB) and a standalone Org note in ~/org/books/.
If the Org note for the selected book does not exist, it is created automatically
with metadata and a NOTER_DOCUMENT property."
    (interactive)
    (require 'calibredb)
    (unless (derived-mode-p 'calibredb-search-mode 'calibredb-show-mode)
      (call-interactively #'calibredb))
    (let* ((candidate (car (calibredb-find-candidate-at-point)))
           (id (calibredb-getattr candidate :id))
           (title (or (calibredb-getattr candidate :book-title)
                      (calibredb-getattr candidate :title)))
           (author (or (calibredb-getattr candidate :author-sort)
                       (calibredb-getattr candidate :author)))
           (title* (or title "Unknown"))
           (author* (or author "Unknown"))
           (file-author
            (if (and author* (string-match "\\`\\([^,&]+\\)" author*))
                (string-trim (match-string 1 author*))
              author*))
           (book-path (or (calibredb-get-file-path candidate t)
                          (calibredb-get-file-path candidate nil)))
           ;; Notes directory under your default-directory (~/org/).
           (books-notes-dir (expand-file-name "books" my/notes-root-dir))
           ;; Slug for filename: first-author-title, lowercased and cleaned.
           (slug (downcase
                  (replace-regexp-in-string
                   "[^a-z0-9 ]" ""
                   (format "%s - %s" file-author file-title))))
           (slug (replace-regexp-in-string " " "-" slug))
           (note-file (expand-file-name (concat slug ".org") books-notes-dir)))
      (message "ID=%S TITLE=%S AUTHOR=%S FILE=%S" id title author book-path)
      (unless book-path
        (user-error "No file for \"%s\" (ID: %s)" title* id))
      (make-directory books-notes-dir t)
      (unless (file-exists-p note-file)
        (with-temp-file note-file
          (insert
           (format
            "#+TITLE: %s\n#+AUTHOR: %s\n#+CREATED: %s\n#+ROAM_TAGS: book\n\n* Overview\n:PROPERTIES:\n:NOTER_DOCUMENT: %s\n:ID: %s\n:END:\n\n* Analysis and Inference\n\n"
            title* author*
            (format-time-string "%Y-%m-%d")
            (expand-file-name book-path)
            (org-id-new)))))
      (when (fboundp 'my/bibnote-normalize-file)
        (my/bibnote-normalize-file note-file (expand-file-name book-path) title*))
      (find-file (expand-file-name book-path))
      (split-window-right)
      (other-window 1)
      (find-file note-file)
      (goto-char (point-min))
      (if (re-search-forward "^\\* Overview" nil t)
          (progn
            (org-entry-get nil "NOTER_DOCUMENT")
            (org-noter))
        (message "Warning: No Overview heading found; Org-noter not started."))
      (message "Opened: %s by %s with Org-noter session" title* author*))))
#+END_SRC

* Annotation and Transclusion Helpers

** Image Directory

#+BEGIN_SRC emacs-lisp
(defun my/get-image-dir-for-note (note-file)
  "Return directory for images for NOTE-FILE."
  (expand-file-name "images" (file-name-directory note-file)))
#+END_SRC

** Front-matter and Annotation Helpers

#+BEGIN_SRC emacs-lisp
(defun my/org-get-front-matter-prop (file prop)
  "Return PROP from FILE-level keywords or the first heading in FILE."
  (when (and file (file-exists-p file))
    (let* ((existing-buf (get-file-buffer file))
           (buf (or existing-buf (find-file-noselect file)))
           (result
            (with-current-buffer buf
              (save-excursion
                (goto-char (point-min))
                (let* ((kw (org-collect-keywords (list prop)))
                       (val (cadr (assoc-string prop kw t))))
                  (or val
                      (progn
                        (goto-char (point-min))
                        (when (re-search-forward org-heading-regexp nil t)
                          (org-entry-get nil prop)))))))))
      (unless existing-buf (kill-buffer buf))
      result)))

(defun my/org-get-annot-page (marker)
  "Extract page number from NOTER_PAGE of heading at MARKER."
  (with-current-buffer (marker-buffer marker)
    (save-excursion
      (goto-char marker)
      (let ((np (org-entry-get nil "NOTER_PAGE")))
        (when (and np (not (string-empty-p np)))
          (when (string-match "::\\([0-9]+\\)" np)
            (match-string 1 np)))))))

(defun my/org-short-author (author)
  "Return short form of AUTHOR, e.g. \"Surname, First et al.\"."
  (when (and author (not (string-empty-p author)))
    (let* ((parts (split-string author "[&]\\| and " t "[ \t\n]+"))
           (first (string-trim (car parts))))
      (if (> (length parts) 1)
          (format "%s et al." first)
        first))))
#+END_SRC

** Transclusion with Attribution

#+BEGIN_SRC emacs-lisp
(defun my/org-insert-transclude-from-id-with-front-author (&optional id)
  "Insert #+transclude line and LaTeX attribution using ID.
If ID is nil, offer completion over all IDs in currently open Org buffers."
  (interactive (list (org-id-get-with-outline-path-completion)))
  (let ((m (org-id-find id 'marker)))
    (unless m
      (user-error "ID not found in open Org buffers: %s" id))
    (let* ((src-file (buffer-file-name (marker-buffer m)))
           (raw-author (my/org-get-front-matter-prop src-file "AUTHOR"))
           (author (my/org-short-author raw-author))
           (title (my/org-get-front-matter-prop src-file "TITLE"))
           (page (my/org-get-annot-page m)))
      (insert (format "#+transclude: [[id:%s]] :only-contents\n\n" id))
      (when (or author title page)
        (insert "#+LATEX: \\begin{flushright}\n")
        (insert "-- ")
        (when author (insert author))
        (when title
          (if author
              (insert (format ", %s" title))
            (insert title)))
        (when page
          (if (or author title)
              (insert (format ", Pg No: %s" page))
            (insert (format "Pg No: %s" page))))
        (insert "\n#+LATEX: \\end{flushright}\n")))))
#+END_SRC

* Image Capture

#+BEGIN_SRC emacs-lisp
;; ──────────────────────────────────────────────────────────────
;; Automate Image Capture for Annotations
;; ──────────────────────────────────────────────────────────────
(defun my/save-pdf-region-to-datestamp (&optional whole-page)
  "Save PDF region (or WHOLE-PAGE) as JPG and insert link at cursor in Org note."
  (interactive "P")
  (when (derived-mode-p 'pdf-view-mode)
    (require 'org-noter)
    (unless (bound-and-true-p org-noter--session)
      (when (y-or-n-p "No Org-noter session. Start one now? ")
        (org-noter)))
    (let* ((pdf-file (buffer-file-name))
           (note-win (org-noter--get-notes-window))
           (note-buf (when note-win (window-buffer note-win)))
           (note-file (when note-buf (buffer-file-name note-buf))))
      (unless note-file
        (user-error "No associated Org note window found. Use C-c i a to open PDF + note."))
      (let* ((image-dir (my/get-image-dir-for-note note-file))
             (timestamp (format-time-string "%Y-%m-%d-%H%M%S"))
             (filename (expand-file-name (format "%s.jpg" timestamp) image-dir))
             (resolution 150)
             (caption (read-string "Optional caption: "))
             raw-edges quads page-size pixel-width pixel-height crop-x crop-y crop-w crop-h
             (link-text (format "#+CAPTION: %s\n[[file:%s]]\n"
                                (if (string-empty-p caption) "Captured image" caption)
                                (file-relative-name filename (file-name-directory note-file)))))
        (make-directory image-dir t)
        (if whole-page
            (shell-command
             (format "pdftoppm -jpeg -r %d -f %d -l %d '%s' > '%s'"
                     resolution
                     (pdf-view-current-page) (pdf-view-current-page)
                     pdf-file filename))
          (setq raw-edges (condition-case nil
                              (pdf-view-active-region)
                            (error nil)))
          (setq quads (if (numberp (car-safe raw-edges))
                          (cdr raw-edges)
                        raw-edges))
          (if (and quads
                   (listp quads)
                   (= (length quads) 1)
                   (let ((quad (car quads)))
                     (and (listp quad)
                          (= (length quad) 4)
                          (cl-every #'numberp quad))))
              (let ((quad (car quads)))
                (setq page-size   (pdf-info-pagesize (pdf-view-current-page))
                      pixel-width  (* (car page-size) (/ resolution 72.0))
                      pixel-height (* (cdr page-size) (/ resolution 72.0))
                      crop-x (* (nth 0 quad) pixel-width)
                      crop-y (* (nth 1 quad) pixel-height)
                      crop-w (* (- (nth 2 quad) (nth 0 quad)) pixel-width)
                      crop-h (* (- (nth 3 quad) (nth 1 quad)) pixel-height))
                (shell-command
                 (format "pdftoppm -jpeg -r %d -f %d -l %d -x %.0f -y %.0f -W %.0f -H %.0f '%s' > '%s'"
                         resolution
                         (pdf-view-current-page) (pdf-view-current-page)
                         crop-x crop-y crop-w crop-h
                         pdf-file filename)))
            (user-error "No valid region selected. Drag to select or use C-c i S for whole page.")))
        (with-current-buffer note-buf
          (insert link-text)
          (save-buffer))
        (message "Saved → %s"
                 (file-relative-name filename (file-name-directory note-file)))))))
#+END_SRC

* Keybindings

#+BEGIN_SRC emacs-lisp
;; ── C-c i a: open any PDF + note (bib or generic) ──
(global-set-key (kbd "C-c i a") #'my/open-pdf-and-note)

;; ── C-c i b: open Calibre book + note (laptop only) ──
(when (eq my-device 'laptop)
  (with-eval-after-load 'calibredb
    (define-key calibredb-search-mode-map (kbd "C-c i b")
      #'my/open-calibre-book-and-note)))

;; ── pdf-view local bindings ──
(with-eval-after-load 'pdf-view
  (define-key pdf-view-mode-map [drag-mouse-1] 'ignore)
  (define-key pdf-view-mode-map (kbd "<down-mouse-1>") 'pdf-view-mouse-set-region)
  (define-key pdf-view-mode-map (kbd "<S-down-mouse-1>") 'pdf-view-mouse-set-region-rectangle)
  (define-key pdf-view-mode-map (kbd "C-c i s") 'my/save-pdf-region-to-datestamp)
  (define-key pdf-view-mode-map (kbd "C-c i S")
    (lambda () (interactive) (my/save-pdf-region-to-datestamp t))))
#+END_SRC

* Org-roam Capture Template

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-roam-capture-templates
             '("b" "bibliography note" plain #'my/load-roam-bib-template
               :target (file+head "literature/${citar-citekey}.org" "")
               :unnarrowed t :immediate-finish t))
#+END_SRC

* Transclusion Settings

#+BEGIN_SRC emacs-lisp
;; Reduce bloat: skip drawers during transclusion
(with-eval-after-load 'org-transclusion
  (setq org-transclusion-exclude-elements '(property-drawer)))

(provide 'notextn)
;;; notextn.el ends here
#+END_SRC
