#+TITLE: Bibliography and Org-Noter Integration
#+AUTHOR: Ram
#+TODO: ACTIVE | CANCELLED
#+STARTUP: indent
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+DATE: 2025-10-20
#+CREATED: %U
#+LAST_MODIFIED: [%<%Y-%m-%d %a %H:%M>]

This file provides a clean, minimal, and robust integration between:
- Citar
- Org-roam
- PDF Tools
- Org-Noter

It handles both bibliography notes and generic PDFs (books, whitepapers, etc.)
with a unified command set under =C-c i=.

* Core Functions
#+BEGIN_SRC emacs-lisp
;;; notextn.el --- Org-noter + Citar + PDF Tools integration     -*- lexical-binding: t; -*-

(require 'org)
(require 'org-id)
(require 'org-noter)
(require 'org-noter-pdftools)
(require 'pdf-tools nil t)

;; ──────────────────────────────────────────────────────────────
;; Org-noter settings
;; ──────────────────────────────────────────────────────────────
(setq org-noter-notes-search-path
      (list (expand-file-name "literature" org-roam-directory))
      org-noter-default-notes-file-names '("notes.org" "annotations.org")
      org-noter-auto-save-last-location t
      org-noter-highlight-selected-text t
      org-noter-insert-note-no-questions t
      org-noter-hide-other nil)

;; ──────────────────────────────────────────────────────────────
;; Helper: first PDF path from Citar
;; ──────────────────────────────────────────────────────────────
(defun my/citar-extract-first-path (x)
  "Return first string path in X or nil."
  (cond ((null x) nil)
        ((stringp x) x)
        ((vectorp x) (when (> (length x) 0) (my/citar-extract-first-path (aref x 0))))
        ((listp x) (my/citar-extract-first-path (car x)))
        ((hash-table-p x) (let (found)
                           (maphash (lambda (_ v)
                                      (unless found (setq found (my/citar-extract-first-path v))))
                                    x)
                           found))
        (t nil)))

;; ──────────────────────────────────────────────────────────────
;; Normalize note file
;; ──────────────────────────────────────────────────────────────
(defun my/bibnote-normalize-file (note-file &optional pdf title)
  "Ensure note file has proper structure and properties."
  (let ((buf (find-file-noselect note-file)))
    (with-current-buffer buf
      (save-excursion
        (goto-char (point-min))
        (unless (re-search-forward "^\\*\\s-+\\S-" nil t)
          (goto-char (point-max))
          (insert (format "* %s\n\n" (or title "Overview"))))
        (goto-char (point-min))
        (re-search-forward "^\\*\\s-+\\S-")
        (unless (org-entry-get (point) "ID") (org-id-get-create))
        (when pdf
          (org-entry-put (point) "NOTER_DOCUMENT" (expand-file-name pdf)))
        (goto-char (point-min))
        (unless (re-search-forward "^\\*+\\s-+Annotations\\b" nil t)
          (goto-char (point-max))
          (unless (bolp) (insert "\n"))
          (insert "* Annotations\n\n")))
      (when (buffer-modified-p) (save-buffer))))
  note-file)

;; ──────────────────────────────────────────────────────────────
;; Clean template (no dead Bib Entry)
;; ──────────────────────────────────────────────────────────────
(defun my/load-template (filename)
  "Load template or return clean fallback."
  (let ((path (expand-file-name filename (expand-file-name "template" user-emacs-directory))))
    (if (file-exists-p path)
        (with-temp-buffer (insert-file-contents path) (buffer-string))
      (message "Template %s not found; using fallback." path)
      "#+TITLE: %s\n#+ROAM_ALIASES: %s\n#+ROAM_REFS: cite:%s\n* Overview\n:PROPERTIES:\n:AUTHOR: %s\n:DOI: %s\n:YEAR: %s\n:NOTER_DOCUMENT: %s\n:ID: %s\n:END:\n* Annotations\n")))

;; ──────────────────────────────────────────────────────────────
;; Bibliography note template
;; ──────────────────────────────────────────────────────────────
(defun my/load-roam-bib-template (&optional citekey title)
  "Generate bibliography note from Citar entry."
  (let* ((template (my/load-template "roam-bib.org"))
         (citekey (or citekey (plist-get org-roam-capture--info 'citar-citekey) ""))
         (entry (ignore-errors (when citekey (citar-get-entry citekey))))
         (title (or title (plist-get org-roam-capture--info 'title)
                    (and entry (cdr (assoc "title" entry))) "Untitled"))
         (author (or (and entry (cdr (assoc "author" entry))) ""))
         (doi (or (and entry (cdr (assoc "doi" entry))) ""))
         (date (or (and entry (cdr (assoc "date" entry))) ""))
         (year (or (and entry (cdr (assoc "year" entry)))
                   (and (> (length date) 3) (substring date 0 4)) ""))
         (file (or (ignore-errors (my/citar-extract-first-path (citar-get-files citekey))) ""))
         (noter-document (if (string-empty-p file) "" file))
         (id (org-id-new)))
    (format template title citekey citekey author doi year noter-document id)))

;; ──────────────────────────────────────────────────────────────
;; Unified opener
;; ──────────────────────────────────────────────────────────────
(defun my/open-pdf-and-note (&optional key-or-pdf)
  "Open PDF and note. Use 'generic for non-bib files."
  (interactive)
  (require 'citar nil t)
  (let* ((is-bib (not (eq key-or-pdf 'generic)))
         (key (if is-bib
                  (substring (or key-or-pdf (concat "@" (citar-select-ref))) 1)
                nil))
         (pdf (if is-bib
                  (my/citar-extract-first-path (citar-get-files key))
                (read-file-name "Select PDF: ")))
         (entry (when is-bib (ignore-errors (citar-get-entry key))))
         (title (or (when entry (cdr (assoc "title" entry)))
                    (when pdf (file-name-base pdf))
                    "Overview"))
         (notes-dir (expand-file-name "literature" org-roam-directory))
         (note-file (expand-file-name
                     (if is-bib (concat key ".org")
                       (concat (downcase (replace-regexp-in-string "[^a-z0-9-]" "-" title)) ".org"))
                     notes-dir)))
    (make-directory notes-dir t)
    (unless (file-exists-p note-file)
      (with-temp-file note-file
        (if is-bib
            (insert (my/load-roam-bib-template key title))
          (insert (format "#+TITLE: %s\n* Overview\n:PROPERTIES:\n:ID: %s\n:NOTER_DOCUMENT: %s\n:END:\n* Annotations\n"
                          title (org-id-new) (or pdf "")))))
      (my/bibnote-normalize-file note-file pdf title))
    (find-file pdf)
    (split-window-right)
    (find-file note-file)
    (goto-char (point-min))
    (re-search-forward "^\\* ")
    (condition-case err (org-noter) (error (message "Org-noter failed: %s" err)))
    (message "Opened %s note → %s"
             (if is-bib "bibliography" "generic")
             (file-name-nondirectory note-file))))

;; ──────────────────────────────────────────────────────────────
;; C-c i p — 100% working with new Org-noter (no more listp/struct errors)
;; ──────────────────────────────────────────────────────────────
(with-eval-after-load 'org-noter-pdftools
  (defun my/org-noter--convert-location (loc)
    "Convert any Org-noter location (old list or new struct) to (page . top) cons."
    (cond
     ((consp loc) loc)  ; old format
     ((fboundp 'org-noter-pdftools--location-page)
      (cons (org-noter-pdftools--location-page loc)
            (org-noter-pdftools--location-height loc)))
     (t (cons (or (plist-get loc :page) 1)
              (or (plist-get loc :height) 0.0)))))

  (advice-add 'org-noter--pretty-print-location-for-title
              :around
              (lambda (orig loc &rest args)
                (let ((converted-loc (my/org-noter--convert-location loc)))
                  (apply orig converted-loc args))))

  (defun my/pdf-insert-selection-to-note ()
    "Insert selected text as precise Org-noter note (C-c i p)."
    (interactive)
    (unless (bound-and-true-p org-noter--session)
      (if (y-or-n-p "No session. Start Org-noter? ") (org-noter) (user-error "Aborted")))
    (let* ((text (and (pdf-view-active-region-p)
                      (string-trim (mapconcat #'identity (pdf-view-active-region-text) "\n"))))
           (page (pdf-view-current-page))
           (timestamp (format-time-string "%Y-%m-%d %H:%M"))
           (raw-loc (condition-case nil
                        (org-noter--get-precise-location)
                      (void-function (cons page 0.0))))
           (loc (my/org-noter--convert-location raw-loc)))
      (when text
        (org-noter-insert-note loc)
        (goto-char (point-max))
        (unless (looking-back "^\\*\\*.*\n" nil)
          (insert "\n** Page " (number-to-string page) " — " timestamp "\n")
          (insert ":PROPERTIES:\n:NOTER_PAGE: " (number-to-string page) "\n:END:\n\n"))
        (insert "#+BEGIN_QUOTE\n" text "\n#+END_QUOTE\n")
        (save-buffer)
        (message "Inserted note on page %d" page))))

  (with-eval-after-load 'pdf-tools
    (define-key pdf-view-mode-map (kbd "C-c i p") #'my/pdf-insert-selection-to-note)))

;; ──────────────────────────────────────────────────────────────
;; Keymap
;; ──────────────────────────────────────────────────────────────
(unless (boundp 'my/citar-map) (define-prefix-command 'my/citar-map))
(global-set-key (kbd "C-c i") 'my/citar-map)
(define-key my/citar-map (kbd "a") #'my/open-pdf-and-note)
(define-key my/citar-map (kbd "g") (lambda () (interactive) (my/open-pdf-and-note 'generic)))
(define-key my/citar-map (kbd "n") #'org-noter)
(define-key my/citar-map (kbd "p") #'my/pdf-insert-selection-to-note)
(define-key my/citar-map (kbd "A") #'org-noter-pdftools-insert-annotations)

;; ──────────────────────────────────────────────────────────────
;; Org-roam capture template
;; ──────────────────────────────────────────────────────────────
(add-to-list 'org-roam-capture-templates
             '("b" "bibliography note" plain #'my/load-roam-bib-template
               :target (file+head "literature/${citar-citekey}.org" "")
               :unnarrowed t :immediate-finish t))

(provide 'notextn)
;;; notextn.el ends here
#+END_SRC