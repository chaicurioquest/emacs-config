#+TITLE: Org Extensions Configuration
#+TODO: ACTIVE | CANCELLED
#+STARTUP: indent
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+DATE: 2025-08-13
#+CREATED: %U
#+LAST_MODIFIED: [%<%Y-%m-%d %a %H:%M>]

This file contains consolidated configurations for general Org-mode extensions, including attachments, smart TAB, hooks, capture templates, and LaTeX/PDF export processes. VLSI-specific diagram settings (TikZ, CircuitTikZ, ditaa) are in ~org/customxtn.org~ (optional). Tangled to ~org/orgxtn.el~ and loaded via ~my/tangle-if-needed~ in ~config.org~.

Features:
- Centralized attachments directory
- Smart TAB integration (Yasnippet → CDLaTeX → Org-cycle)
- Vertical PDF preview
- Auto-update #+LAST_MODIFIED
- Simple Org-roam capture template loader
- Minimal Babel support (shell)
- LaTeX/PDF export via latexmk

* Quick Reference Table
| Feature                        | Keybinding / Usage                            | Notes |
|--------------------------------|-----------------------------------------------|-------|
| Attachment directory           | N/A                                           | All Org attachments in `.attach/` subfolder |
| Smart TAB function             | =TAB=                                         | Expands snippet → CDLaTeX → Org-cycle |
| Fit PDF to height              | =M-x my/pdf-view-fit-height=                  | Works in pdf-tools buffer |
| Auto-update `#+LAST_MODIFIED`  | On save                                       | Uses `before-save-hook` |
| Capture template loader        | `(my/load-template FILE)`                     | Replaces `${setupfile}` with actual path |
| Babel shell blocks             | `#+BEGIN_SRC sh` … `#+END_SRC`                | No confirm on eval |
| PDF export                     | `C-c C-e l o`                                 | Uses `latexmk` with `Fba` |

* ACTIVE General Org Settings
General Org-mode variables, functions, hooks, and templates that are not tightly coupled to export or Babel. These were moved from ~config.org~'s * ACTIVE General Settings and related sections, as they are Org-specific and have no external dependencies beyond Org itself (e.g., ~setupfile~ is assumed defined globally in ~config.org~).

#+BEGIN_SRC emacs-lisp
;; Attachments relative to org file, in `.attach` folder
(setq org-attach-directory ".attach")

;; Smart TAB: Yasnippet (inline) → CDLaTeX (math) → Org-cycle
(with-eval-after-load 'org
  (require 'yasnippet)  ;; Load yasnippet here if not elsewhere
  (defun my/org-smart-tab ()
    "Smart TAB: Yasnippet → CDLaTeX → Org-cycle."
    (interactive)
    (cond
     ((org-at-heading-p) (org-cycle))
     ((org-in-src-block-p) (org-cycle))
     ((org-at-table-p 'any) (org-table-next-field))
     ((or (and (fboundp 'yas-maybe-expand) (yas-maybe-expand))
          (and (fboundp 'yas-expand) (yas-expand))) t)
     ((and (or (bound-and-true-p cdlatex-mode) (bound-and-true-p org-cdlatex-mode))
           (org-inside-LaTeX-fragment-p)) (cdlatex-tab))
     (t (org-cycle))))
  (define-key org-mode-map (kbd "TAB") #'my/org-smart-tab))
#+END_SRC

** ACTIVE Smart Org + PDF vertical preview
#+BEGIN_SRC emacs-lisp
(defun my/org-pdf-vertical-view ()
  "Open corresponding PDF in vertical split right of current org buffer."
  (interactive)
  (let ((pdf-file (concat (file-name-sans-extension (buffer-file-name)) ".pdf")))
    (when (file-exists-p pdf-file)
      (select-window (split-window-right))
      (find-file pdf-file))))
(global-set-key (kbd "C-c v") #'my/org-pdf-vertical-view)
#+END_SRC

** ACTIVE Org Hooks for file handling

#+BEGIN_SRC emacs-lisp
;; enable auto-revert when entering org buffers
(add-hook 'org-mode-hook (lambda () (auto-revert-mode 1)))

;; prefer file-notify (less polling) when available
(setq auto-revert-use-notify t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;my-org-update-tag-targets function scans all agenda files for headings with :TAG_TARGET: properties
;;constructing the mapping by prefixing tags with "+" (Org's match syntax for tags) and associating them with generated IDs
(defun my-org-update-tag-targets ()
  (interactive)
  (setq my-org-refile-to-ids
        (let (list)
          (org-map-entries
           (lambda ()
             (cons (concat "+" (org-entry-get (point) "TAG_TARGET"))
                   (org-id-get-create)))
           "TAG_TARGET={.}" 'agenda)))
  (customize-save-variable 'my-org-refile-to-ids my-org-refile-to-ids))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; For adding new targets on the fly, my-org-add-tag-target  set the property and updating the list immediately
(defun my-org-add-tag-target (tag)
  (interactive "MTag: ")
  (org-entry-put (point) "TAG_TARGET" tag)
  (push (cons (concat "+" tag) (org-id-get-create)) my-org-refile-to-ids)
  (customize-save-variable 'my-org-refile-to-ids my-org-refile-to-ids))

;; Performs the actual refiling by identifying matching headings and moving them to the target
  (defun my-org-refile-matches-to-heading (match target-heading-id &optional scope copy)
  "Refile matching headings to target."
  (if-let (target-marker (org-id-find target-heading-id t))
      (let* ((target-rfloc (with-current-buffer (marker-buffer target-marker)
                             (goto-char target-marker)
                             (list (org-get-heading)
                                   (buffer-file-name (marker-buffer target-marker))
                                   nil
                                   target-marker)))
             (headings-to-copy (org-map-entries (lambda () (point-marker)) match scope)))
        (mapc
         (lambda (heading-marker)
           (with-current-buffer (marker-buffer heading-marker)
             (goto-char heading-marker)
             (org-refile nil nil target-rfloc (when copy "Copy"))))
         (nreverse headings-to-copy))
        (message "%s %d headings!" (if copy "Copied" "Refiled") (length headings-to-copy)))
     (warn "Could not find target %S" target-heading-id)))

;; my-org-refile-to-tag-targets iterates over all rules to execute batch refiles

(defun my-org-refile-to-tag-targets ()
  (interactive)
  (dolist (rule my-org-refile-to-ids)
    (my-org-refile-matches-to-heading (car rule) (cdr rule) 'file)))  ; Scope to inbox.org
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Added 2025-07-28: Hook for #+LAST_MODIFIED: update while editing the org file.

(defun my/org-update-last-modified ()
  "Update #+LAST_MODIFIED: after #+CREATED: in current Org buffer."
  (when (derived-mode-p 'org-mode)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^#\\+LAST_MODIFIED:.*$" nil t)
        (beginning-of-line)
        (kill-line 1))
      (goto-char (point-min))
      (if (re-search-forward "^#\\+CREATED:.*$" nil t)
          (let ((created-end (line-end-position)))
            (goto-char created-end)
            (insert (format "\n#+LAST_MODIFIED: [%s]" (format-time-string "%Y-%m-%d %a %H:%M"))))
        (goto-char (point-min))
        (let ((metadata-end (point)))
          (while (looking-at "^\\(#\\|[ \t]*$\\)")
            (setq metadata-end (line-end-position))
            (forward-line 1))
          (goto-char metadata-end)
          (unless (looking-back "\n" nil) (insert "\n"))
          (insert (format "#+LAST_MODIFIED: [%s]\n" (format-time-string "%Y-%m-%d %a %H:%M"))))))))

(add-hook 'org-mode-hook
          (lambda ()
            ;; buffer-local add (nil t => append, make buffer-local)
            (add-hook 'before-save-hook #'my/org-update-last-modified nil t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Added 2025-07-28: capture template, loading content from generic-note.org.
(defvar my/generic-note-template
  (with-temp-buffer
    (insert-file-contents (expand-file-name "template/generic-note.org" user-emacs-directory))
    (goto-char (point-min))
    (while (search-forward "${setupfile}" nil t)
      (replace-match setupfile t t))
    (goto-char (point-min))
    (while (search-forward "${bib-path}" nil t) ;; added 2025-10-28 bib path
      (replace-match bib-path t t))
    (buffer-string)))

(setq org-capture-templates
  `(("n" "Generic Note" plain
     (file (lambda () (read-file-name "New Note File: " default-directory nil nil ".org")))
     ,my/generic-note-template
     :empty-lines 1 :prepend t)))
#+END_SRC

* ACTIVE Babel Configuration
Settings for Org Babel code execution. Currently enables shell blocks; expand here for future languages (e.g., Python, Emacs Lisp) without creating a new file unless it grows excessively.

#+BEGIN_SRC emacs-lisp
;; Enable bash/shell  for general-purpose code and latex block code execution.
(org-babel-do-load-languages 'org-babel-load-languages '((shell . t) (latex . t)))  
   
  ;; Add future Babel settings here, e.g.:
  ;; (org-babel-do-load-languages 'org-babel-load-languages '((python . t) (emacs-lisp . t)))
  ;; (setq org-confirm-babel-evaluate nil) ;; No confirmation for code evaluation
#+END_SRC

** Org noter + Citar annotation: added 2025-11-02
#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :straight t
  :after (pdf-tools org)
  :config
  (setq org-noter-notes-search-path (list (expand-file-name "literature" org-roam-directory)))
  (setq org-noter-auto-save-last-location t
        org-noter-always-create-frame nil
        org-noter-highlight-selected-text t
        org-noter-insert-note-no-questions t)
  (setq org-noter-hide-other nil)
  (define-key pdf-view-mode-map (kbd "i") 'org-noter-insert-note)
  (define-key pdf-view-mode-map (kbd "I") 'org-noter-insert-precise-note)
  (message "✅ Org-noter ready for PDF annotations."))
#+END_SRC

** pdf annotation using org noter
#+BEGIN_SRC emacs-lisp
(use-package org-noter-pdftools
  :straight t
  :after (org-noter pdf-tools)
  :config
  ;; Enable PDF annotations to Org conversion
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+END_SRC

** Custom function: annotation

#+BEGIN_SRC emacs-lisp
;; --- Key function: open note & PDF side-by-side, prepare for annotation ---
(defun my/open-paper-and-note ()
  "Open PDF & org-roam note for a bib entry, always setting NOTER_DOCUMENT."
  (interactive)
  (require 'citar)
  (require 'org-noter)
  (let* ((key (citar-select-ref))
         (entry (when key (citar-get-entry key)))
         (files (ignore-errors (citar-get-files key)))
         (pdf (my/citar-extract-first-path files))
         (title (when entry (or (cdr (assoc "title" entry)) key)))
         (note-file (expand-file-name (concat key ".org")
                                     (expand-file-name "literature" org-roam-directory))))
    (unless (file-directory-p (file-name-directory note-file))
      (make-directory (file-name-directory note-file) t))
    (delete-other-windows)
    (if pdf
        (progn (split-window-right)
               (find-file pdf)
               (when (fboundp 'pdf-view-fit-page-to-window)
                 (pdf-view-fit-page-to-window))
               (other-window 1))
      (message "No PDF found for citekey: %s" key))
    (unless (file-exists-p note-file)
      (find-file note-file)
      (let ((id (org-id-new)))
        (insert (format "#+TITLE: %s\n#+ROAM_REFS: cite:%s\n:PROPERTIES:\n:ID: %s\n:NOTER_DOCUMENT: %s\n:END:\n\n* Overview\n\n* Annotations\n\n* Bib Entry\n[cite:@%s]\n"
                        title key id (or pdf "") key))
        (save-buffer)))
    (find-file note-file)
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward ":NOTER_DOCUMENT:" nil t)
        (when pdf
          (re-search-forward ":END:" nil t)
          (insert (format "\n:NOTER_DOCUMENT: %s" pdf))
          (save-buffer))))
    (when (and (featurep 'org-noter) pdf)
      (org-noter))))

(global-set-key (kbd "C-c i a") #'my/open-paper-and-note)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; ---------------------------
;; Consolidated: Citar + Org-Noter annotation capture
;; ---------------------------

(require 'citar)
(require 'org-noter)

(defvar my/last-citar-note nil
  "Path to the last bib note opened by `my/annotate-bib-pdf`.")

(defvar my/last-citar-pdf nil
  "Path to the last PDF opened by `my/annotate-bib-pdf`.")

(defvar my/last-citar-key nil
  "Citekey last used with `my/annotate-bib-pdf`.")

(defun my/citar-extract-first-path (x)
  "Recursively extract first string path from X, or nil."
  (cond
   ((null x) nil)
   ((stringp x) x)
   ((hash-table-p x)
    (let (found)
      (maphash (lambda (_k v)
                 (unless found
                   (setq found (my/citar-extract-first-path v))))
               x)
      found))
   ((vectorp x) (and (> (length x) 0) (my/citar-extract-first-path (aref x 0))))
   ((listp x) (my/citar-extract-first-path (car x)))
   (t nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/open-paper-and-note ()
  "Open PDF & org-roam note for a bib entry, always setting NOTER_DOCUMENT to absolute path."
  (interactive)
  (require 'citar)
  (require 'org-noter)
  (let* ((key (citar-select-ref))
         (entry (when key (citar-get-entry key)))
         (files (ignore-errors (citar-get-files key)))
         (pdf (when files (expand-file-name (my/citar-extract-first-path files))))
         (title (when entry (or (cdr (assoc "title" entry)) key)))
         (note-file (expand-file-name (concat key ".org")
                                     (expand-file-name "literature" org-roam-directory))))
    (unless (file-directory-p (file-name-directory note-file))
      (make-directory (file-name-directory note-file) t))
    (delete-other-windows)
    (when pdf
      (split-window-right)
      (find-file pdf)
      (when (fboundp 'pdf-view-fit-page-to-window)
        (pdf-view-fit-page-to-window))
      (other-window 1))
    (unless (file-exists-p note-file)
      (find-file note-file)
      (let ((id (org-id-new)))
        (insert (format "#+TITLE: %s\n#+ROAM_REFS: cite:%s\n:PROPERTIES:\n:ID: %s\n:NOTER_DOCUMENT: %s\n:END:\n\n* Overview\n\n* Annotations\n\n* Bib Entry\n[cite:@%s]\n"
                        title key id (or pdf "") key))
        (save-buffer)))
    (find-file note-file)
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward ":NOTER_DOCUMENT:" nil t)
        (when pdf
          (re-search-forward ":END:" nil t)
          (insert (format "\n:NOTER_DOCUMENT: %s" pdf))
          (save-buffer))))
    (save-buffer)
    (when (and (featurep 'org-noter) pdf)
      (org-noter))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/citar-find-note-file-for-key (key)
  "Return first org-roam note file that matches KEY in citar-notes-paths or org-roam-directory."
  (let* ((dirs (or (and (boundp 'citar-notes-paths) citar-notes-paths)
                   (and (boundp 'org-roam-directory) (list org-roam-directory))
                   (list default-directory)))
         (pattern (concat (regexp-quote key) ".*\\.org\\'"))
         found)
    (dolist (d dirs found)
      (when (and (stringp d) (file-directory-p d) (not found))
        (let ((res (ignore-errors (directory-files-recursively d pattern 1))))
          (when (and res (> (length res) 0))
            (setq found (car res))))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/pdf-insert-selection-to-note ()
  "Insert selected PDF text or note to current bib note under Annotations."
  (interactive)
  (let* ((selection (ignore-errors (pdf-view-active-region-text)))
         (page (ignore-errors (when (fboundp 'pdf-view-current-page) (pdf-view-current-page))))
         (time (format-time-string "%Y-%m-%d %H:%M"))
         (note-buf (my/citar-find-note-file-for-key my/last-citar-key)))
    (unless (and note-buf (buffer-live-p (get-file-buffer note-buf)))
      (user-error "Could not find or open a bib note buffer. Run C-c i a first."))
    (with-current-buffer note-buf
      (goto-char (point-min))
      (if (re-search-forward "^\\*+ Annotations" nil t)
          (goto-char (match-end 0))
        (goto-char (point-max))
        (unless (bolp) (insert "\n"))
        (insert "* Annotations\n\n"))
      (let ((heading (format "** Page %s — %s\n" (or page "-") time)))
        (insert heading)
        (when page
          (insert ":PROPERTIES:\n")
          (insert (format ":NOTER_PAGE: %s\n" page))
          (insert ":END:\n\n"))
        (when (and selection (not (string-blank-p selection)))
          (insert (format "%s\n\n" selection))
          (save-buffer))))
    (message "Inserted selection into %s (page %s)" note-buf (or page "-"))))

(define-key pdf-view-mode-map (kbd "C-c i p") #'my/pdf-insert-selection-to-note)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Disable org-ref
(ignore-errors (unload-feature 'org-ref t))
(straight-override-recipe '(org-ref :type built-in :local-repo nil :files nil))
(setq load-path (cl-remove-if (lambda (p) (string-match-p "org-ref" p)) load-path))
(unless (featurep 'org-ref)
  (defvar org-ref-bibliography-notes nil)
  (defvar org-ref-default-bibliography nil)
  (defvar org-ref-pdf-directory nil)
  (provide 'org-ref))
#+END_SRC
