#+TITLE: Bibliography and Org-Noter Integration
#+AUTHOR: Ram
#+TODO: ACTIVE | CANCELLED
#+STARTUP: indent
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+DATE: 2025-10-20
#+CREATED: %U
#+LAST_MODIFIED: [%<%Y-%m-%d %a %H:%M>]

This file provides a clean, minimal, and robust integration between:
- Citar
- Org-roam
- PDF Tools
- Org-Noter

It handles both bibliography notes and generic PDFs (books, whitepapers, etc.)
with a unified command set under =C-c i=.

* Core Functions
#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'org-id)

;; Extract first valid PDF path from Citar (handles strings, lists, vectors, hashes)
(defun my/citar-extract-first-path (x)
  "Return the first string path inside X (string/list/vector/hash-table) or nil."
  (cond
   ((null x) nil)
   ((stringp x) x)
   ((vectorp x) (when (> (length x) 0) (my/citar-extract-first-path (aref x 0))))
   ((listp x) (my/citar-extract-first-path (car x)))
   ((hash-table-p x)
    (let (found)
      (maphash (lambda (_k v)
                 (unless found (setq found (my/citar-extract-first-path v))))
               x)
      found))
   (t nil)))

;; Ensure note has proper first heading + ID + NOTER_DOCUMENT
(defun my/bibnote-normalize-file (note-file &optional pdf title)
  "Ensure NOTE-FILE has a top-level heading with ID and NOTER_DOCUMENT.
Optionally set TITLE if provided."
  (let ((buf (find-file-noselect note-file)))
    (with-current-buffer buf
      (save-excursion
        ;; Move any top-level PROPERTIES drawer into first heading
        (goto-char (point-min))
        (when (re-search-forward "^:PROPERTIES:" nil t)
          (let ((start (match-beginning 0)) end id val)
            (when (re-search-forward "^:END:" nil t)
              (setq end (point))
              (save-restriction
                (narrow-to-region start end)
                (goto-char (point-min))
                (when (re-search-forward "^:ID:[ \t]*\\(.*\\)$" nil t)
                  (setq id (string-trim (match-string 1))))
                (when (re-search-forward "^:NOTER_DOCUMENT:[ \t]*\\(.*\\)$" nil t)
                  (setq val (string-trim (match-string 1)))))
              (delete-region start end)
              (goto-char (point-min))
              (unless (re-search-forward "^\\*\\s-+\\S-" nil t)
                (goto-char (point-max))
                (insert (format "* %s\n\n" (or title "Overview"))))
              (goto-char (point-min))
              (re-search-forward "^\\*\\s-+\\S-")
              (org-entry-put (point) "ID" id)
              (when val (org-entry-put (point) "NOTER_DOCUMENT" val))))))
        ;; Ensure first heading exists
        (goto-char (point-min))
        (unless (re-search-forward "^\\*\\s-+\\S-" nil t)
          (goto-char (point-max))
          (insert (format "* %s\n\n" (or title "Overview"))))
        ;; Final setup on first heading
        (goto-char (point-min))
        (re-search-forward "^\\*\\s-+\\S-")
        (unless (org-entry-get (point) "ID")
          (org-id-get-create))
        (when pdf
          (org-entry-put (point) "NOTER_DOCUMENT" (expand-file-name pdf))))
      (when (buffer-modified-p) (save-buffer)))
    note-file)

;; Unified opener — works for bib entries AND generic PDFs
(defun my/open-pdf-and-note (&optional key-or-pdf)
  "Open PDF + note side-by-side. Defaults to bib mode (citekey prompt).
If KEY-OR-PDF is '@key', treats as bib. If 'generic, prompts for PDF file."
  (interactive)
  (require 'citar nil t)
  (let* ((is-bib (not (eq key-or-pdf 'generic)))
         (key (if is-bib
                  (substring (or key-or-pdf (concat "@" (citar-select-ref))) 1)
                nil))
         (pdf (if is-bib
                  (my/citar-extract-first-path (citar-get-files key))
                (read-file-name "Select PDF: ")))
         (entry (when is-bib (citar-get-entry key)))
         (title (or (when entry (cdr (assoc "title" entry)))
                    (when pdf (file-name-base pdf))
                    (read-string "Note title: " "Overview")))
         (notes-dir (expand-file-name "literature" org-roam-directory))
         (note-file (expand-file-name
                     (if is-bib (concat key ".org")
                       (concat (downcase (replace-regexp-in-string "[^a-z0-9-]" "-" title)) ".org"))
                     notes-dir))
         (pdf-win (selected-window))
         (note-win (split-window-right)))
    (unless (file-directory-p notes-dir) (make-directory notes-dir t))
    (unless (file-exists-p note-file)
      (with-temp-file note-file
        (insert (format "* %s\n:PROPERTIES:\n:ID: %s\n:NOTER_DOCUMENT: %s\n:END:\n\n* Notes\n\n"
                        title (org-id-new) (or pdf "")))))
    (my/bibnote-normalize-file note-file pdf title)
    (when pdf (select-window pdf-win) (find-file pdf))
    (select-window note-win) (find-file note-file)
(message "Opened %s note → %s. Start Org-Noter with C-c i n." (if is-bib "bibliography" "generic") (file-name-nondirectory note-file))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
(defun my/pdf-insert-selection-to-note ()
  "Insert selected text from PDF into the associated literature note.
Creates or finds the '* Annotations' heading (case-insensitive) and adds a
timestamped entry with page link and NOTER_PAGE property."
  (interactive)
  (unless (derived-mode-p 'pdf-view-mode)
    (user-error "This command only works in PDF View mode"))

  ;; Get selection and metadata
  (when-let* ((region-text (ignore-errors (pdf-view-active-region-text)))
              (sel (string-trim (mapconcat #'identity region-text "\n")))
              (page (pdf-view-current-page))
              (page-str (number-to-string page))
              (timestamp (format-time-string "%Y-%m-%d %H:%M"))
              (pdf-path (expand-file-name (buffer-file-name))))

    ;; Find note (fallbacks: global var → Org-Noter → open buffer → disk search)
    (let ((note-file
           (or (and (boundp 'my/last-citar-note) my/last-citar-note
                    (file-exists-p my/last-citar-note) my/last-citar-note)
               (and (bound-and-true-p org-noter--session)
                    (org-noter--session-notes-filepath org-noter--session))
               (when-let ((buf (seq-find
                                (lambda (b)
                                  (and-let* ((name (buffer-file-name b)))
                                    (string-match-p "/literature/.*\\.org\\'" name)))
                                (buffer-list))))
                 (buffer-file-name buf))
               ;; Optional: Comment this block if disk search feels slow/bloated
               (catch 'found
                 (dolist (file (directory-files-recursively
                                (expand-file-name "literature" org-roam-directory)
                                "\\.org\\'"))
                   (with-temp-buffer
                     (insert-file-contents file)
                     (when (re-search-forward
                            (concat "^[ \t]*:NOTER_DOCUMENT:[ \t]*"
                                    (regexp-quote pdf-path))
                            nil t)
                       (throw 'found file))))))))

      ;; No note? Prompt to create (optional: comment if not needed)
      (unless note-file
        (unless (y-or-n-p "No literature note found. Create one now? ")
          (user-error "Aborted"))
        (call-interactively #'my/open-paper-and-note)
        (setq note-file (or my/last-citar-note
                            (and (bound-and-true-p org-noter--session)
                                 (org-noter--session-notes-filepath org-noter--session)))))

      ;; Insert into note
      (with-current-buffer (find-file-noselect note-file)
        (org-with-wide-buffer
         (goto-char (point-min))

         ;; Find/create heading (flexible regex: any level, spacing, case-insensitive)
         (unless (re-search-forward "^\\*+\\s-+[aA]nnotations\\b" nil t)
           (goto-char (point-max))
           (unless (bolp) (insert "\n"))
           (insert "* Annotations\n\n"))

         ;; Position after heading
         (re-search-forward "^\\*+\\s-+[aA]nnotations\\b")
         (end-of-line)
         (newline-and-indent)

         ;; Insert entry
         (insert (format "** Page %s — %s\n" page-str timestamp))
         (insert ":PROPERTIES:\n")
         (insert (format ":NOTER_PAGE: %s\n" page))
         (insert ":END:\n\n")

         ;; Optional back-link (only if var set)
         (when (and (boundp 'my/last-citar-pdf) my/last-citar-pdf
                    (file-exists-p my/last-citar-pdf))
           (insert (format "[[file:%s::%s][Open PDF at page %s]]\n\n"
                           my/last-citar-pdf page page)))

         ;; Quote or placeholder
         (if (string-empty-p sel)
             (insert (format "_(no text selected – %s)_\n\n" timestamp))
           (insert "#+BEGIN_QUOTE\n" sel "\n#+END_QUOTE\n\n"))

         (save-buffer)))

      ;; Display and confirm
      (display-buffer (find-buffer-visiting note-file))
      (message "Inserted page %s → %s" page-str (file-name-nondirectory note-file)))))

;; Key binding
(with-eval-after-load 'pdf-tools
  (define-key pdf-view-mode-map (kbd "C-c i p") #'my/pdf-insert-selection-to-note))
#+END_SRC

* Keybindings & Safe Handler
#+BEGIN_SRC emacs-lisp
;; C-c i — your annotation hub
(unless (boundp 'my/citar-map) (define-prefix-command 'my/citar-map))
(global-set-key (kbd "C-c i") 'my/citar-map)
(define-key my/citar-map (kbd "a") #'my/open-pdf-and-note)                    ;; main: bib mode (citekey prompt)
(define-key my/citar-map (kbd "g") (lambda () (interactive) (my/open-pdf-and-note 'generic))) ;; generic: PDF prompt
(define-key my/citar-map (kbd "n") #'my/start-noter)                         ;; manual Org-Noter
(define-key my/citar-map (kbd "p") #'my/pdf-insert-selection-to-note)        ;; insert selection
(define-key my/citar-map (kbd "A") #'org-noter-pdftools-insert-annotations) ;; import all annotations
;; Safe, idempotent PDF annotation → Org jump handler
(defun my/org-noter-pdftools-safe-handler (_annotation &rest _)
  "Safely jump to Org heading when clicking a PDF annotation."
  (when (and (derived-mode-p 'pdf-view-mode)
             (featurep 'org-noter-pdftools)
             (fboundp 'org-noter-pdftools-jump-to-note)
             (boundp 'org-noter--session)
             org-noter--session
             (org-noter--valid-session org-noter--session))
    (ignore-errors (org-noter-pdftools-jump-to-note))))

(with-eval-after-load 'pdf-annot
  (setq pdf-annot-activate-handler-functions
        (seq-remove (lambda (f)
                      (and (functionp f)
                           (string-match-p "noter-pdftools" (format "%S" f))))
                    pdf-annot-activate-handler-functions))
  (unless (memq #'my/org-noter-pdftools-safe-handler pdf-annot-activate-handler-functions)
    (add-hook 'pdf-annot-activate-handler-functions
              #'my/org-noter-pdftools-safe-handler)))

(provide 'reading)

;; Guard Org-Noter handlers against invalid windows
(advice-add 'org-noter--doc-location-change-handler :around
            (lambda (orig &rest args)
              (when (window-valid-p (selected-window))
                (apply orig args))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'pdf-tools
  (define-key pdf-view-mode-map (kbd "C-c i p") #'my/pdf-insert-selection-to-note)
  (define-key pdf-view-mode-map (kbd "C-c i n") #'my/start-noter))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org-roam
  (add-to-list 'org-roam-capture-templates
               '("b" "bibliography note" plain
                 (function my/load-roam-bib-template)
                 :target (file+head "literature/${citar-citekey}.org"
                                   "#+TITLE: ${title}\n#+ROAM_REFS: cite:${citar-citekey}\n\n* Overview\n:PROPERTIES:\n:DOI: %s\n:YEAR: %s\n:NOTER_DOCUMENT: %s\n:END:\n\n* Annotations\n\n* Bib Entry\n[[cite:@${citar-citekey}]]")
                 :unnarrowed t
                 :immediate-finish t)))
#+END_SRC